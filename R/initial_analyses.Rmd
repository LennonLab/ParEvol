---
title: "Evolutionary trajectories in the Long-term Evolution Experiment"
author: "William R. Shoemaker, Jay T. Lennon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
  - \usepackage{array}
output: pdf_document
geometry: margin=2.54cm
editor_options: 
  chunk_output_type: console
---

## 1) Background

One of the goals of our research is to determine whether independently evolving populations are evolving under similar trajectories. One of the more recent and thorough attempts at addressing this goal is a recent study that examined fine-scale temporal sampling of Richard Lenski's Long-term Evolution Experiment (Good et al., 2017). In Good et al. (2017) the authors propose a measure of gene multiplicity to detect evolutionary parallelism at the gene level among replicate populations. The multiplicity for each gene is 

$$m_{i}=n_{i}\cdot \frac{\overline{L}}{L_{i}}$$

where $n_{i}$ is the number of mutations in gene $i$ across all replicate populations, $L_{i}$ is the number of nonsynonymous sites in gene $i$, and $\overline{L}$ is the average value of $L_{i}$ across all genes in the genome. Under the null model that the probability that a gene contains a mutation is simply proportional to the length of the gene ($p_{i}\propto L_{i}$), all genes have the same expected multiplicity $\overline{m}=n_{tot}/n_{genes}$, where $n_{tot}$ is the number of mutations among all replicate populations and $n_{genes}$ is the number of genes in the genome. 

In Good et al. (2017) the authors determine that in nonmutator LTEE populations approximately half of all mutations occurred in genes with $m_{i}\geq 2$, twice as many as expected under the null model. The authors concluded that the null model should be replaced with an alternative where mutations are assigned to each gene with probability

$$p_{i}\propto L_{i}r_{i}$$

where $r_{i}$ is an enrichment factor that is not equal to 1. Under the alternative model the maximum likelihood estimator for the enrichment factor is the ratio of observed and expected multiplicities, $r_{i}=m_{i}/ \overline{m}$ and the net increase relative to the null model across all genes is

$$\Delta \ell=\sum_{i}n_{i}\mathrm{log}\left ( \frac{m_{i}}{\overline{m}} \right )$$

The authors note that the maximum likelihood estimate $r_{i}$ may overfit the data and propose that a more appropriate alternative model would be one that focuses on a subset $I$ of the genes where $r_{i}\neq 1$, while the remaining genes have $r_{i}= 1$. The authors identify this set of genes using a cricial $P$-value, $P^{*}$, for a the False Discovery Rate $\alpha=0.05$ and modify the enrichment factors as follows

$$r_{i}= \begin{Bmatrix}
\frac{m_{i}}{\overline{m}} \left ( \frac{1-\frac{\sum_{i\epsilon I} L_{i} }{\overline{L}n_{genes}}}{1-\frac{\sum_{i\epsilon I}n_{i}}{n_{tot}}} \right )& \mathrm{if}\;  i \;  \epsilon \; I\\ 
1& \mathrm{else}.
\end{Bmatrix}$$

This is an innovative approach that builds off of statistical distributions used to describe parallel evolutionary outcomes. However, this measure pools the mutation data for all replicate populations for each gene. To allow for the comparison between replicate populations so that we can begin to develop statistics to determine whether replicate populations have similar evolutionary trajectories from pooled sequencing, the multiplicity statistics presented in Good et al. (2017) need to be deconstructed to the level of individual populations. To accomplish this goal, we propose a multiplicity measure for the $i$th gene in the $j$th population

$$m_{i,j}=n_{i,j}\cdot \frac{\overline{L}}{L_{i}}$$

with the expected multiplicity in population $j$ of $\overline{m_{j}}=n_{tot,j}/ n_{genes}$, giving a log-likelihood compared to the null model (which is now $r_{i,j}=m_{i,j}/ \overline{m_{j}}$) 

$$\Delta \ell_{j}=\sum_{i}n_{i,j}\mathrm{log}\left ( \frac{m_{i,j}}{\overline{m_{j}}} \right )$$

and the modified enrichment factor 

$$r_{i,j}= \begin{Bmatrix}
\frac{m_{i,j}}{\overline{m_{j}}} \left ( \frac{1-\frac{\sum_{i\epsilon I} L_{i} }{\overline{L}n_{genes}}}{1-\frac{\sum_{i\epsilon I}n_{i,j}}{n_{tot,j}}} \right )& \mathrm{if}\;  i \;  \epsilon \; I\\ 
1& \mathrm{else}.
\end{Bmatrix}$$

Using these modified population level gene enrichment scores and the publically available data presented in Good et al. (2017), we calculate the multiplicity score for each gene within each population for all genes within set $I$, generating a gene-by-population multiplicity matrix. We then used Principal Coordinates Analysis (PCoA) to reduce the dimensionality of the dataset and visualize the evolutionary trajectories of the six nonmutator populations. To determine whether or not the rate that mutations are acquired in each gene decreases, we calculated the Euclidean distance of the first three PCoA axes between timepoints for each population.


## 2) Setup work environment

```{r, results = 'hide', message = FALSE, warning = FALSE, echo=FALSE}
rm(list=ls())
getwd()
#setwd("~/GitHub/ParEvol")
knitr::opts_knit$set(root.dir = '~/GitHub/ParEvol/')

# Load dependencies
# Load dependencies
require("vegan")
require("png")
require("grid")
library("scales")
library("data.table")
```


## 3) Load and clean data


```{r, echo=FALSE}
pop_by_gene <- c("data/ltee/gene_by_pop_m_I.txt")
df <- read.table(paste(pop_by_gene, collapse = ''), sep = "\t", 
                 header = TRUE, row.names = 1)
# only look at nonmutators (for now)
complete_nonmutator_lines <- c('m5','m6','p1','p2','p4','p5')
complete_mutator_lines <- c('m1','m4','p3')
to_keep <- rownames(df) %like% "m5" + rownames(df) %like% "m6" + 
  rownames(df) %like% "p1" + rownames(df) %like% "p2" + 
  rownames(df) %like% "p4" + rownames(df) %like% "p5"
df.noMut <- df[as.logical(to_keep),]
df.no0 <- df.noMut[apply(df.noMut[,-1], 1, function(x) !all(x==0)),]
```


## 4) Make and visualize PCoA ordination


```{r, message = FALSE, warning = FALSE, echo=FALSE}
df.no0.db <- vegdist(df.no0, method = "bray", upper = TRUE, diag = TRUE)
df.pcoa <- cmdscale(df.no0.db, eig = TRUE, k = 3) 
explainvar1 <- round(df.pcoa$eig[1] / sum(df.pcoa$eig), 3) * 100
explainvar2 <- round(df.pcoa$eig[2] / sum(df.pcoa$eig), 3) * 100

times <- c()
for (x in rownames(df.pcoa$points)){
  time <- strsplit(x, '_')[[1]][2]
  times <- c(times, time)
}
# function to return color gradient for time points
get.times.cols <- function(pcoa.points, times){
  # get colors for times
  times.sorted <- as.character(sort(as.numeric(unique(times))))
  number.times <- length(times.sorted)
  colfunc.nonMut <- colorRampPalette(c("lightgreen", "darkgreen"))
  time.cols.nonMut <- colfunc.nonMut(number.times)
  times.cols.pcoa <- c()
  for (x in rownames(pcoa.points)){
    time <- strsplit(x, '_')[[1]][2]
    pop <- toString(strsplit(x, '_')[[1]][1])
    time.position <- match(time, times.sorted)
    if (pop %in% complete_nonmutator_lines){
      time.color <- time.cols.nonMut[time.position]
    }
    times.cols.pcoa <- c(times.cols.pcoa, time.color)
  }
  return(times.cols.pcoa)
}

pcoa.m5 <- df.pcoa$points[rownames(df.pcoa$points) %like% "m5", ]
pcoa.m6 <- df.pcoa$points[rownames(df.pcoa$points) %like% "m6", ]
pcoa.p1 <- df.pcoa$points[rownames(df.pcoa$points) %like% "p1", ]
pcoa.p2 <- df.pcoa$points[rownames(df.pcoa$points) %like% "p2", ]
pcoa.p4 <- df.pcoa$points[rownames(df.pcoa$points) %like% "p4", ]
pcoa.p5 <- df.pcoa$points[rownames(df.pcoa$points) %like% "p5", ]

m5.cols <- get.times.cols(pcoa.m5, times)
m6.cols <- get.times.cols(pcoa.m6, times)
p1.cols <- get.times.cols(pcoa.p1, times)
p2.cols <- get.times.cols(pcoa.p2, times)
p4.cols <- get.times.cols(pcoa.p4, times)
p5.cols <- get.times.cols(pcoa.p5, times)

# make plot
png(filename = paste(c("figs/pcoa.png"), collapse = ''),
    width = 1200, height = 900, res = 96*2)
#layout(matrix(1:6, 2, 3))
#par(mar = c(0.5, 2.5, 0.5, 0.5), oma = c(4, 1, 1, 1))
#par(mar =c(0.5, 3.1, 1.1, 0.5), oma = c(2, 1, 0, 0 ), pty="s")#, mai = c(0.3, 0.2, 0.2, 0.2))
#par(mfrow = c(2,3), mar =c(0, 3.1, 1.1, 0.5), oma = c(5, 4, 0, 0 ), pty="s")
par(mfrow = c(2, 3),   
    oma = c(5, 4, 0, 0), # two rows of text at the outer left and bottom margin
    mar = c(1.5, 3.1, 1.1, 0.5), # space for one row of text at ticks and to separate plots
    pty="s") # make the plots square

# plots for each population
pcoa.p2.plot <- plot(pcoa.p2[ ,1], pcoa.p2[ ,2],
                     xlim = c(-0.7, 0.7), ylim = c(-0.7, 0.7), 
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara+2")
points(pcoa.p2[ ,1], pcoa.p2[ ,2],
       pch = 0, cex = 1.5, bg = "gray", col = alpha(m6.cols, 0.5), lwd  = 3)
# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

pcoa.p4.plot <- plot(pcoa.p4[ ,1], pcoa.p4[ ,2], 
                     xlim = c(-0.7, 0.7), ylim = c(-0.7, 0.7),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara+4")
points(pcoa.p4[ ,1], pcoa.p4[ ,2],
       pch = 2, cex = 1.5, bg = "gray", col = alpha(m6.cols, 0.5), lwd  = 3)
# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

pcoa.m6.plot <- plot(pcoa.m6[ ,1], pcoa.m6[ ,2],
                     xlim = c(-0.7, 0.7), ylim = c(-0.7, 0.7), 
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara-6")
points(pcoa.m6[ ,1], pcoa.m6[ ,2],
       pch = 4, cex = 1.5, bg = "gray", col = alpha(m6.cols, 0.5), lwd  = 3)
# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

pcoa.p1.plot <- plot(pcoa.p1[ ,1], pcoa.p1[ ,2], 
                     xlim = c(-0.7, 0.7), ylim = c(-0.7, 0.7),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara+1")
points(pcoa.p1[ ,1], pcoa.p1[ ,2],
       pch = 1, cex = 1.5, bg = "gray", col = alpha(m6.cols, 0.5), lwd  = 3)
# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

pcoa.m5.plot <- plot(pcoa.m5[ ,1], pcoa.m5[ ,2],
                     xlim = c(-0.7, 0.7), ylim = c(-0.7, 0.7), 
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara-5")
points(pcoa.m5[ ,1], pcoa.m5[ ,2],
       pch = 3, cex = 1.5, bg = "gray", col = alpha(m5.cols, 0.5), lwd  = 3)
# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

pcoa.p5.plot <- plot(pcoa.p5[ ,1], pcoa.p5[ ,2],
                     xlim = c(-0.7, 0.7), ylim = c(-0.7, 0.7),  
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara+5")
points(pcoa.p5[ ,1], pcoa.p5[ ,2],
       pch = 5, cex = 1.5, bg = "gray", col = alpha(m6.cols, 0.5), lwd  = 3)
# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

mtext(paste("PCoA 1 (", explainvar1, "%)", sep = ""), side=1, line=1, 
      cex=1.5, col="black", outer=TRUE)  
mtext(paste("PCoA 2 (", explainvar2, "%)", sep = ""), side=2, line=1, 
      cex=1.5, col="black", outer=TRUE)

dev.off()

# Show Plot
img <- readPNG(paste(c("figs/pcoa.png"), collapse = ''))
grid.raster(img)
```


So we see from the ordination that Ara+2, Ara+4, and Ara-6 have similar non-linear trends in ordination space. Likewise, Ara+1 and Ara-5 have similar trends. However, Ara+5 does not show much of a trend and there is no immediate explanation. To determine the sets of genes that contribute to each of these trajectories as well as how the variation in signatures of parallelism changes over time, we will be adapting appropriate measures presented in Good et al. (eqs. 80 - 87 in the supplement) to account for variation between populations.


## 5) Quantifing Euclidean distance between timepoints

A basic prediction from Fisher's geometric model (FGM) of adaptive phenotypic evolution is that the magnitude of change in phenotypic space declines over the course of the adaptive walk towards an optimum. While we are using genetic data instead of phenotypic data, it is possible that the rate of change in ordination space could exhibit a qualitatively similar trend. This prediction assumes that some form of FGM describes  phenotypic evolution in the LTEE and that the genotype-to-phenotype map is linear to the extent that qualitative similarities between the two distributions are not erased. There are other explanations for this pattern, one of which may be a variation of the global fitness-mediated epistasis model described in Good and Desai (2014). 


```{r fig.align='center', fig.width=3, fig.height=3, message = FALSE, warning = FALSE,  echo=FALSE}
# Show Plot
img.fisher <- readPNG(paste(c("figs/fisher_geom.png"), collapse = ''))
grid.raster(img.fisher,  just = 'centre')
```

An example of an adaptive walk towards an optimum on a 2 dimensional form of Fisher's geometric model.


To examine the decay in the rate of change with time, we quantified the pair-wise Euclidean distance ($d()$) between sequential timepoints for the first three PCoA axes ($d(\mathbf{t_{i}}, \mathbf{t_{i+1}})$) for each population. We then plotted the second time point of the sequential pair-wise distance ($t_{i+1}$) against the Euclidean distance.

```{r, message = FALSE, warning = FALSE, echo=FALSE}
times.sorted <- as.character(sort(as.numeric(unique(times))))
time_steps <- c()
for (index in seq(1, length(head(times.sorted, -1)))) {
  time_step <- paste(times.sorted[index], times.sorted[index+1], sep = "_")
  time_steps <- c(time_steps, time_step)
}

euc.df <- as.data.frame(matrix(data=NA,nrow=length(complete_nonmutator_lines), 
                               ncol=length(tail(times.sorted, -1))))
rownames(euc.df) <- complete_nonmutator_lines
colnames(euc.df) <- tail(times.sorted, -1)

for (pop in complete_nonmutator_lines) {
  for (time_step in time_steps){
    time1 <- strsplit(time_step, '_')[[1]][1]
    time2 <- strsplit(time_step, '_')[[1]][2]
    pop.time1 <- paste(pop, time1, sep = "_")
    pop.time2 <- paste(pop, time2, sep = "_")
    if ( (pop.time1 %in% rownames(df.pcoa$points)) 
         & (pop.time2 %in% rownames(df.pcoa$points)) ) {
      euc.dist <- dist(rbind(df.pcoa$points[pop.time1, ], df.pcoa$points[pop.time2, ]))[1]
      euc.df[pop, time2] <- euc.dist
    }
  } 
}

euc.df.p2 <- euc.df['p2',] 
euc.df.p2.clean <- euc.df.p2[,!is.infinite(colSums(euc.df.p2)) 
                                         &  !is.na(colSums(euc.df.p2)) 
                                   & (log10(colSums(euc.df.p2)) > -10) ]
euc.df.p4 <- euc.df['p4',] 
euc.df.p4.clean <- euc.df.p4[,!is.infinite(colSums(euc.df.p4)) 
                                         &  !is.na(colSums(euc.df.p4)) 
                                   & (log10(colSums(euc.df.p4)) > -10) ]
euc.df.m6 <- euc.df['m6',] 
euc.df.m6.clean <- euc.df.m6[,!is.infinite(colSums(euc.df.m6)) 
                                         &  !is.na(colSums(euc.df.m6)) 
                                   & (log10(colSums(euc.df.m6)) > -10) ]
euc.df.p1 <- euc.df['p1',] 
euc.df.p1.clean <- euc.df.p1[,!is.infinite(colSums(euc.df.p1)) 
                                         &  !is.na(colSums(euc.df.p1)) 
                                   & (log10(colSums(euc.df.p1)) > -10) ]
euc.df.m5 <- euc.df['m5',] 
euc.df.m5.clean <- euc.df.m5[,!is.infinite(colSums(euc.df.m5)) 
                                         & !is.na(colSums(euc.df.m5)) 
                             & (log10(colSums(euc.df.m5)) > -10)]
euc.df.p5 <- euc.df['p5',] 
euc.df.p5.clean <- euc.df.p5[,!is.infinite(colSums(euc.df.p5)) 
                                         &  !is.na(colSums(euc.df.p5)) 
                             & (log10(colSums(euc.df.p5)) > -10) ]

png(filename = paste(c("figs/euc_pcoa.png"), collapse = ''),
    width = 1200, height = 900, res = 96*2)
par(mfrow = c(2, 3),   
    oma = c(5, 4, 0, 0), # two rows of text at the outer left and bottom margin
    mar = c(1.5, 3.1, 1.1, 0.5), # space for one row of text at ticks and to separate plots
    pty="s") # make the plots square

# plots for each population
euc.p2.plot <- plot(colnames(euc.df.p2.clean), euc.df.p2.clean, 
                    xlim = c(0, 60000), ylim = c(0, 0.25),
                    pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                    axes = FALSE, xlab = '', ylab ='', main = "Ara+2")
points(colnames(euc.df.p2.clean), euc.df.p2.clean,
       pch = 1, cex = 1.5, bg = "gray",  lwd  = 1)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
box(lwd = 2)

pcoa.p4.plot <- plot(colnames(euc.df.p4.clean), euc.df.p4.clean,  
                     xlim = c(0, 60000), ylim = c(0, 0.25),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara+4")
points(colnames(euc.df.p4.clean), euc.df.p4.clean,
       pch = 1, cex = 1.5, bg = "gray",  lwd  = 1)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
box(lwd = 2)

pcoa.m6.plot <- plot(colnames(euc.df.m6.clean), euc.df.m6.clean,
                     xlim = c(0, 60000), ylim = c(0, 0.25),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara-6")
points(colnames(euc.df.m6.clean), euc.df.m6.clean,
       pch = 1, cex = 1.5, bg = "gray",  lwd  = 1)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
box(lwd = 2)

pcoa.p1.plot <- plot(colnames(euc.df.p1.clean), euc.df.p1.clean,  
                     xlim = c(0, 60000), ylim = c(0, 0.25),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara+1")
points(colnames(euc.df.p1.clean), euc.df.p1.clean,
       pch = 1, cex = 1.5, bg = "gray",  lwd  = 1)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
box(lwd = 2)

pcoa.m5.plot <- plot(colnames(euc.df.m5.clean), euc.df.m5.clean,
                     xlim = c(0, 60000), ylim = c(0, 0.25),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara-5")
points(colnames(euc.df.m5.clean), euc.df.m5.clean,
       pch = 1, cex = 1.5, bg = "gray",  lwd  = 1)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
box(lwd = 2)

pcoa.p5.plot <- plot(colnames(euc.df.p5.clean), euc.df.p5.clean,
                     xlim = c(0, 60000), ylim = c(0, 0.25),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = '', ylab ='', main = "Ara+5")
points(colnames(euc.df.p5.clean), euc.df.p5.clean,
       pch = 1, cex = 1.5, bg = "gray",  lwd  = 1)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
box(lwd = 2)

mtext('Generations', side=1, line=1, 
      cex=1.5, col="black", outer=TRUE)  
mtext('Euclidean distance', side=2, line=1, 
      cex=1.5, col="black", outer=TRUE)

dev.off()

# Show Plot
img <- readPNG(paste(c("figs/euc_pcoa.png"), collapse = ''))
grid.raster(img)
```

While we see considerable variation, a number of populations show a qualitative trend where Euclidean distance between time points decreases with time. We are working on identifying and applying appropriate statistical models to describe this trend and determine the extent that it's consistent  across populations. We are also working to identify the set of potential explanations for this trend.  


## 6) Mean centroid distance

A central question we want to answer from our own evolution experiments is whether independently evolving populations reach similar evolutionary endpoints. To examine this, we  quantified the Euclidean distance between each population and the median in ordination space of all populations sampled at a given time-point (i.e., the centroid). We then plotted the centroid distance for all populations (open circles) and the mean centroid distance (closed circles) against generations.


```{r, message = FALSE, warning = FALSE, echo=FALSE}
df.no0.nop5 <- df.no0[!rownames(df.no0)  %like% "p5", ]
df.no0.nop5.db <- vegdist(df.no0.nop5, method = "bray", upper = TRUE, diag = TRUE)
df.no0.nop5.groups <- sapply(strsplit(rownames(df.no0.nop5),"_"), `[`, 2)

beta.disp <- betadisper(d = df.no0.nop5.db, group = df.no0.nop5.groups)

get.euc.dist.2D <- function(beta.disp, groups, axes_number){
  centroids <- beta.disp$centroids[,1:axes_number]
  posistions <- beta.disp$vectors[,1:axes_number]
  # get euclidean distancs from first three axes
  eucs <- c()
  pop.name <- c()
  times <- c()
  for(i in groups) {
    centroid.i <- centroids[i, ]
    positions.i <- posistions[rownames(posistions) %like% paste("_", i, sep = ""), ]
    for(j in 1:nrow(positions.i)) {
      position.j <- positions.i[j,]
      sample <- rownames(positions.i)[j]
      euc.dist.j <- dist(rbind(position.j, centroid.i))
      eucs <- c(eucs, euc.dist.j)
      pop.name <- c(pop.name, sample)
      times <- c(times, i)
    }
  }
  pop.euc <- cbind(pop.name, eucs, times) 
  return(data.frame(pop.euc))
}
euc.mat.m <- get.euc.dist.2D(beta.disp, unique(df.no0.nop5.groups), 3)

png(filename = paste(c("figs/mcd.png"), collapse = ''),
    width = 1200, height = 900, res = 96*2)
par(mar = c(5, 5, 1, 2) + 0.1)

euc.mat.m$times <- as.integer(as.character(euc.mat.m$times))
euc.mat.m$eucs <- as.numeric(as.character(euc.mat.m$eucs))
x <- euc.mat.m$times 
y <- euc.mat.m$eucs

xy.mean <- aggregate(euc.mat.m[,2], list(euc.mat.m$times), mean )
x.mean <- xy.mean$Group.1
y.mean <- xy.mean$x
plot.mean <- plot(x, y,  
                     xlim = c(0, 60000), ylim = c(0, max(y)),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = 'Generations', 
                  ylab ='Euclidean distance to centroid')
points(x, y, pch = 1, cex = 1, bg = "gray",  lwd  = 1)
points(x.mean, y.mean, pch = 16, cex = 1.5, bg = "gray", 
       col = alpha('black', 0.8), lwd  = 3)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
box(lwd = 2)

dev.off()
# Show Plot
img <- readPNG(paste(c("figs/mcd.png"), collapse = ''))
grid.raster(img)

```


The scatter of the points around the mean clearly decreases with time, suggesting that there may be a relationship between the variance in the degree of parallel evolution with time. To examine this, we plotted the standard deviation of the mean centroid distance against the number of generations.


```{r, message = FALSE, warning = FALSE, echo=FALSE}
# make standard deviation plot
xy.sd <- aggregate(euc.mat.m[,2], list(euc.mat.m$times), sd )
x.sd <- xy.sd$Group.1
y.sd <- xy.sd$x

png(filename = paste(c("figs/mcd_sd.png"), collapse = ''),
    width = 1200, height = 900, res = 96*2)
par(mar = c(5, 7, 1, 2) + 0.1)
plot.df <- plot(x.sd, y.sd,  
                     xlim = c(0, 60000), ylim = c(0, max(y.sd)),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = 'Generations', 
                  ylab ='')
points(x.sd, y.sd, pch = 16, cex = 1.5, bg = "gray", 
       col = alpha('black', 0.8), lwd  = 3)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
mtext("Standard deviation of\neuclidean distance to centroid", side=2, line=3.5, cex=1.3, outer=FALSE)

box(lwd = 2)
dev.off()
# Show Plot
img <- readPNG(paste(c("figs/mcd_sd.png"), collapse = ''))
grid.raster(img)
```


The standard deviation for the last approximately 10,000 generations is clearly disproportionately skewed by some outlier timepoints from population Ara+2, the reason for these unusually high Euclidean distance values in Ara+2 is unclear. If we remove these points and make the same plot, we see that the relationship between the standard deviation of Euclidean distance to the centroid and time is clearly unimodal and right-skewed.

```{r,  message = FALSE, warning = FALSE, echo=FALSE}
euc.mat.m.noP2 <-  euc.mat.m[!euc.mat.m$pop.name  %like% "p2", ]
euc.mat.m.noP2$times <- as.integer(as.character(euc.mat.m.noP2$times))
euc.mat.m.noP2$eucs <- as.numeric(as.character(euc.mat.m.noP2$eucs))
xy.sd.noP2 <- aggregate(euc.mat.m.noP2$eucs, list(euc.mat.m.noP2$times), sd )
x.noP.sd <- xy.sd.noP2$Group.1
y.noP.sd <- xy.sd.noP2$x

png(filename = paste(c("figs/mcd_sd_noP2.png"), collapse = ''),
    width = 1200, height = 900, res = 96*2)
par(mar = c(5, 7, 1, 2) + 0.1)
plot.df <- plot(x.noP.sd, y.noP.sd,  
                     xlim = c(0, 60000), ylim = c(0, max(y.sd)),
                     pch = 2, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
                     axes = FALSE, xlab = 'Generations', 
                  ylab ='')
points(x.noP.sd, y.noP.sd, pch = 16, cex = 1.5, bg = "gray", 
       col = alpha('black', 0.8), lwd  = 3)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
mtext("Standard deviation of\neuclidean distance to centroid", side=2, line=3.5, cex=1.3, outer=FALSE)

box(lwd = 2)
dev.off()
# Show Plot
img <- readPNG(paste(c("figs/mcd_sd_noP2.png"), collapse = ''))
grid.raster(img)
```


We have written code to determine whether or not this result is significant by generating random gene-by-population multiplicity matrices where the probability that a mutation lands on the gene is simply the gene length ($p_{i}\propto L_{i}$) and are planning on running a permutation test on the gene-by-population multiplicity matrix.


## 7) Replicate observed patterns via simulation

We are currently working to build off of and simulate existing population genetic models to confirm our observed patterns. Right now, we're working to simulate a gene-by-population matrix for the running out of mutations model and a global epistasis model (based off of the one proposed in Good and Desai (2014)). Because we observe two different evolutionary trajectories that ultimately reach the same region of PCoA space, sign epistasis could serve as a potential explanation and we are working to include it in our ongoing simulations. 


## 8) References

Good, B. H., and M. M. Desai. 2014. The impact of macroscopic epistasis on long-term evolutionary dynamics. Genetics 114:172460 

Good, B. H., M. J. McDonald, J. E. Barrick, R. E. Lenski, and M. M. Desai. 2017. The dynamics of molecular evolution over 60,000 generations. Nature 551:45–50